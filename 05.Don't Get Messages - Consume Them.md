## 1. Basic.Get vs Basic.Consume

### 1) Basic.Get

![05_02](https://user-images.githubusercontent.com/124541871/235457344-0b7f0e7d-99fa-4f62-8df4-541f9366d7ee.png)

![05_03](https://user-images.githubusercontent.com/124541871/235457586-8b5060f6-5530-4788-b56a-177bee7a10fd.png)

```
소비자 애플리케이션이 Basic.Get 요청을 사용해 메시지를 검색한다면
Queue에 메시지가 여러 개 있어도 메시지를 받을 때마다 새 요청을 보내야 함.
Basic.Get을 발행할 때 메시지를 검색하는 Queue에 대기 중인 메시지가 있으면 RabbitMQ는 Basic.GetOk RPC로 응답함.
Queue에 대기 중인 메시지가 없으면 Basic.GetEmpty로 응답함.

애플리케이션이 Basic.Get을 사용하면 RabbitMQ의 RPC 응답을 평가해 메시지가 수신됐는지 확인해야 함.
RabbitMQ에서 메시지를 전달받는 프로세스의 경우 대부분 오래 실행되며 주기적으로 메시지가 있는지 확인하고 처리하는 이 방식은 효율적이지 않음.

RabbitMQ와 상호작용해 메시지를 검색하는 가장 간단한 방법이지만, 대부분의 경우 성능에는 좋지 않음.
간단한 메시지 속도 테스트를 수행할 때 Basic.Consume을 사용하면 Basic.Get을 사용하는 것보다 적어도 두 배 빠름.
두 방식의 속도 차이는 Basic.Get의 경우 전달되는 각 요청이 RabbitMQ와 동기 방식으로 통신하며
클라이언트 애플리케이션이 요청 프레임을 보내고 RabbitMQ가 응답을 보내는 것으로 구성되어 오버헤드가 매번 발생하기 때문임.

Basic.Get을 피해야 하는 잠재적인 이유는 메시지 처리량에 더 많은 영향을 주는 것이 메시지 자체가 아닌 Basic.Get의 프레임 평가 작업이고
RabbitMQ는 애플리케이션이 메시지를 요구하는 시기를 결코 알 수 없기 때문에 어떤 방식으로든 전달 프로세스를 최적화할 수 없는 데 있음.
```



### 2) Basic.Consume

![05_04](https://user-images.githubusercontent.com/124541871/235461118-38b049ca-4d80-48c4-ad81-e23b6c138289.png)

```
Basic.Get과는 반대로 Basic.Consume RPC 명령은 메시지를 소비하면 RabbitMQ에 애플리케이션을 등록하고
소비자 애플리케이션에 메시지를 비동기적으로 보내도록 요청함. 이를 흔히 발행자-구독자 패턴 또는 Pub-Sub이라고 부름.

Basic.Get을 이용한 RabbitMQ와의 동기 방식 대신 Basic.Consume으로 메시지를 구독하면
Basic.Cancel을 전송하기 전까지 클라이언트가 RabbitMQ에서 메시지를 자동으로 수신할 수 있음.

Basic.Consume은 RabbitMQ에서 메시지를 수신할 때 한 단계가 생략됨.
소비자 애플리케이션은 RabbitMQ에서 메시지를 받으면 메시지를 평가해 값이 메시지인지 또는 빈 응답인지 확인할 필요가 없음.
하지만 Basic.Get과 마찬가지로, 애플리케이션은 RabbitMQ가 메시지가 처리됐음을 알 수 있도록 message.ack를 호출해야 함.

동기 방식의 Basic.Get과 비동기 방식의 Basic.Consume 중 하나를 선택하는 것은 소비자 애플리케이션을 작성할 때 택해야 할 첫 번째 선택임.
메시지를 발행할 때 발생되는 tradeoff와 마찬가지로 애플리케이션에 대한 선택 사항은 메시지 배달 보장 및 성능에 직접적인 영향을 줄 수 있음.
```

- 소비자 태그

  ```
  애플리케이션에서 Basic.Consume을 실행하면 RabbitMQ로 열린 채널에서 애플리케이션을 식별하는 고유한 문자열이 생성됨.
  소비자 태그라고 불리는 이 문자열은 RabbitMQ의 각 메시지와 함께 애플리케이션에 전송됨.
  
  소비자 태그는 이후에 Basic.Cancel RPC 명령으로 RabbitMQ에 메시지 수신을 취소할 때 사용할 수 있음.
  이는 수신된 각 메시지가 메소드 프레임으로 전달되는 소비자 태그를 포함하기 때문에
  애플리케이션이 동시에 여러 Queue에서 메시지를 수신하는 경우 유용함.
  애플리케이션이 다른 Queue에서 받은 메시지에 대해 다른 작업을 수행해야 하는 경우,
  Basic.Consume 요청에 전달된 소비자 태그를 사용해 메시지 처리 방법을 구분할 수 있음.
  그러나 대부분의 경우 소비자 태그는 클라이언트 라이브러리가 자동으로 처리.
  ```



## 2. Performance tuning consumers

![05_05](https://user-images.githubusercontent.com/124541871/235466095-c4d9cc00-7f48-44a8-abec-6fb6627f8cff.png)

### 1) Using No-Ack mode for faster throughput

```
메시지를 소비할 때 애플리케이션은 자신을 RabbitMQ에 등록하고 메시지를 사용할 수 있을 때 전달되도록 요청함.
애플리케이션이 Basic.Consume RPC 요청을 보낼 때, 인자에는 no-ack 플래그가 있음.
이 플래그가 활성화되면, RabbitMQ는 소비자가 메시지 수신 확인을 하지 않으므로 빠르게 메시지를 보낼 수 있음.

no_ack로 메시지를 소비하는 것은 RabbitMQ가 소비자에게 메시지를 전달하는 가장 빠른 방법이며 메시지를 보내는 가장 안정적인 방법이기도 함.
```

![05_06](https://user-images.githubusercontent.com/124541871/235467428-c3e6eec4-5fda-4865-a3ec-56fbe4b5421b.png)

```
RabbitMQ는 열려 있는 연결을 통해 메시지를 보낼 때 TCP 소켓 연결을 통해 클라이언트와 통신함.
이 연결이 열려 있고 쓰기 가능한 경우 RabbitMQ는 모든 것이 정상적으로 작동하며 메시지가 전달됐다고 가정함.
RabbitMQ가 메시지를 전달하기 위해 소켓에 쓰려고 할 때 네트워크 문제가 발생하면
운영체제에서 RabbitMQ에 문제가 있음을 알리는 소켓 오류가 발생함.
오류가 발생하지 않으면 RabbitMQ는 메시지가 배달됐다고 가정함.
대부분의 경우 메시지를 처리할 때, 클라이언트가 Basic.Ack RPC 응답을 통해 메시지 수신 확인을 전송하고
RabbitMQ는 메시지를 성공적으로 수신했음을 알게 됨.
그러나 메시지 수신 확인을 끄면 RabbitMQ는 수신 확인을 기다리지 않고 가능한 경우 다른 메시지를 전송함.
실제로 RabbitMQ는 소켓 버퍼가 다 찰 때까지 가능한 경우 메시지를 사용자에게 계속 전송함.

일회용 메시지의 경우, 가장 이상적인 방법이지만 위험 요소가 없는 것은 아님.
소비자 애플리케이션이 운영체제의 수신 소켓 버퍼에 100KB 메시지를 버퍼링한 상태에서 장애가 발생할 경우
RabbitMQ는 이미 메시지들을 보낸 것으로 간주하며 애플리케이션이 충돌하고 소켓이 닫힐 때 운영체제에서 읽어야 하는 메시지의 수를 표시하지 않음.
애플리케이션이 직면하는 문제는 운영체제의 소켓 수신 버퍼 크기와 함께 메시지 크기 및 수량에 따라 달라짐.

단일 메시지 전달 후 메시지 수신이 제공하는 것보다 빠른 메시지 처리를 원한다면
소비자 채널 서비스 품질 설정의 prfetching을 제어하는 것이 좋음.
```

- 리눅스에서 수신 소켓 버퍼 늘리기

  ```
  리눅스 운영체제에서 수신 소켓 버퍼 수를 늘리려면
  net.core.rmem_default와 net.core.rmem_max 값을 기본 128KB 값에서 더 큰 값으로 늘려야 함.
  대부분의 환경에는 16MB 값이 적합함.
  대부분의 배포판에서는 /etc/sysctl.conf에서 이 값들을 변경함.
  
  echo 16777216 > /proc/sys/net/core/rmem_default
  echo 16777216 > /proc/sys/net/core/rmem_max
  ```

  



### 2) Controlling consumer prefetching via quality of service settings

```
AMQP 스펙에서는 소비자가 메시지 수신을 확인하기 전에
미리 지정된 수의 메시지를 수신하도록 처리할 수 있는 서비스 품질(QoS, Quality of Service) 설정을 채널에 요청할 수 있음.
QoS 설정을 통해 RabbitMQ는 소비자에게 미리 할당할 메시지 수를 지정해 메시지를 좀 더 효율적으로 보낼 수 있음.

수신 확인을 비활성화(no_ack=True)한 소비자와 달리,
소비자 애플리케이션은 메시지를 확인하기 전에 충돌하는 경우 소켓을 닫으면 미리 가져온 모든 메시지가 Queue로 반환됨.

프로토콜 수준에서 채널에 Basic.QoS RPC 요청을 보내면 서비스 품질이 지정됨.
이때 요청을 전송하는 채널에 대해서만 QoS를 설정할지 혹은 연결된 모든 채널에 대해 QoS를 설정할지 지정할 수 있음.
Basic.QoS RPC 요청은 언제든지 보낼 수 있지만, 보통 소비자가 Basic.Consume RPC 요청을 발행하기 전에 수행함.
```

- Prefetch 값을 최적의 수준으로 교정

  ![05_07](https://user-images.githubusercontent.com/124541871/235471687-fef555c6-cbe0-4555-a352-348642d8ea2d.png)

  ```
  Prefetch 수를 지나치게 할당하면 메시지 처리량에 부정적힌 영향을 미칠 수 있음.
  RabbitMQ에서 동일한 큐에 연결된 다수 소비자는 Round Robin 방식으로 메시지를 수신하는데,
  고속의 소비자 애플리케이션에서는 Prefetch 수가 성능에 영향을 미치는지 벤치마크하는 것이 중요함.
  ```



- 한 번에 여러 메시지 확인하기

  ```
  QoS 설정 중 유용한 또 다른 점은 Basic.Ack RPC 응답과 함께 받은 각 메시지를 개별적으로 하나씩 확인하지 않아도 되는 점임.
  대신 Basic.Ack RPC 응답의 multiple 속성을 True로 설정해 반환하면
  RabbitMQ는 수신 확인하지 않은 모든 메시지를 수신 확인으로 처리함.
  
  동시에 여러 메시지를 수신 확인하면 메시지 처리에 필요한 네트워크 통신을 최소화해 메시지 처리량을 향상시킬 수 있음.
  일부 메시지를 성공적으로 처리하고 애플리케이션이 메시지를 확인하기 전에 장애가 발생한다면,
  모든 미확인 메시지는 Queue로 돌아가서 다른 소비자 프로세스에 의해 처리됨.
  
  QoS뿐 아니라 트랜잭션도 애플리케이션에 대한 메시지 전달 보장을 향상시크는 방법 중 하나임.
  ```



### 3) Using Transactions with Consumers

![05_09](https://user-images.githubusercontent.com/124541871/235473814-f9647690-d8aa-4699-ba71-237420826597.png)

```
메시지를 RabbitMQ에 발행할 때와 마찬가지로 트랜잭션을 사용해 소비자 애플리케이션에서 일괄 작업을 커밋하고 롤백할 수 있음.
트랜잭션은 한 가지 예외적인 상황을 제외하고는 메시지 처리량에 부정적인 영향을 미칠 수 있음.
QoS 설정을 사용하지 않는 경우에도 트랜잭션을 사용해 메시지 확인 응답을 일괄 처리할 때 약간의 성능이 향상됨.

다른 QoS 설정처럼 트랜잭션 방식을 결정할 때도 소비자 애플리케이션의 성능을 벤치마크해 판단하는 것이 좋음.
메시지 수신 확인을 일괄 처리하는 데 사용하든, 메시지를 소비할 때 RPC 응답을 롤백하는 역할로 사용하든
트랜잭션의 실제 성능 영향을 참고하면 메시지 배달 보장과 메시지 처리 간에 적절한 균형을 찾는 데 도움이 됨.

메시지 수신 확인이 비활성화된 소비자 애플리케이션은 트랜잭션이 작동하지 않음.
```

