# Performace tradeoffs in publishing

```
AMQP spec은 메시지를 발행할 때 트랜잭션을 제공하고 있으며,
메시지를 디스크에 저장하는 경우 일반적인 메시지 발행보다 높은 수준의 안정적인 메시징 환경을 제공할 수 있음.
RabbitMQ는 발행자 확인과 같은 추가 기능을 제공하고 있으며 여러 서버에 걸쳐 있는 HA Queue와 같은 다양한 메시지 배달 보장 수준을 선택할 수 있음.
```

## 1. Balancing Delivery speed with guaranteed delivery

![04_01](https://user-images.githubusercontent.com/87686562/233837846-dc213987-5bd7-47d9-baff-55494a3951e3.png)

- 발행 시에 메시지를 Queue에 넣는 것이 얼마나 중요한가?
- 메시지를 라우팅할 수 없는 경우, 발행자에게 메시지를 보내야 하는가?
- 메시지를 라우팅할 수 없는 경우, 차후에 조정하는 다른 곳으로 메시지를 보내야 하는가?
- RabbitMQ 서버에 장애가 발생할 때, 메시지가 손실돼도 괜찮은가?
- RabbitMQ가 새 메시지를 처리할 때, 요청한 모든 메시지를 라우팅한 후 디스크에 저장하는 작업이 정상적으로 실행됐는지를 발행자에게 다시 알려야 하는가?
- 다수 메시지를 라우팅한 후 디스크에 정상적으로 저장됐는데 확인하는 작업을 일괄 처리하는 경우, 메시지를 저장할 Queue에 atomic commit이 필요한가?
- 발행자가 적절한 성능과 메시지 처리량을 달성하는데, 메시지 배달 보장 기능 간에 절충점이 있는가?
- 메시지 발행의 다른 측면이 메시지 처리량 및 성능에 영향을 미치는가?



### 1) What to expect with no guarantees

```
미션 크리티컬한 애플리케이션이 아닌 경우, 일반적인 메시지 발행 중 발생 가능한 모든 장애를 처리할 필요는 없으며,
적절한 처리만 해도 안정적이고 예측 가능한 가동 시간을 확보할 수 있음.
또한, RabbitMQ의 기본 설정으로도 적절한 수준의 안정적인 메시징 환경을 구축할 수 있음.
```



### 2) RabbitMQ won't accept non-routable messages with mandatory set

![04_03](https://user-images.githubusercontent.com/87686562/233838313-9cb776c3-c6e0-4eda-8038-2b9404762099.png)

```
데이터가 항상 RabbitMQ로 배달되도록 보장하려면, RabbitMQ에 발행하는 메시지의 mandatory를 설정함.
mandatory flag는 Basic.Publish RPC 명령과 함께 전달되는 인수인데,
메시지를 라우팅할 수 없으면 Basic.Return RPC를 통해 RabbitMQ가 메시지를 발행자에게 다시 보내도록 지시함.
mandatory flag는 오류 감지 모드를 켜는 것으로 간주할 수 있는데, 메시지 라우팅 실패를 알리는 데 사용함.
메시지 라우팅이 올바르게 처리되면 발행자에게 별도의 메시지를 전송하지 않음.

RabbitMQ의 Basic.Return은 비동기로 동작하며 메시지가 발행된 후 언제든지 발생할 수 있음.
예를 들어 RabbitMQ에 데이터를 발행하는 데 실패할 경우, 발행자가 Basic.Return 호출을 받기 전에 다른 데이터를 계속 발행할 수 있음.
Basic.Return을 처리하도록 설정하지 않은 경우, 발행자가 메시지가 올바르게 발행되지 않았음을 알 수 없음.
```



### 3) Publisher confirms as a lightweight alternative to transactions

![04_04](https://user-images.githubusercontent.com/87686562/233840761-64ec1392-6c36-46ae-bdce-d8ce3526f951.png)

```
RabbitMQ의 발행자 확인은 AMQP 스펙의 확장 기능으로 RabbitMQ 관련 확장을 지원하는 클라이언트 라이브러리에서만 지원됨.
디스크에 메시지를 저장하는 것으로도 메시지 손실을 막을 수 있지만,
이것만으로는 발행자와 RabbitMQ 사이에 메시지가 전달됐음을 확신할 수 없음.
메시지를 발행하기 전에 메시지 발행자는 RabbitMQ에 Confirm.Select RPC 요청을 전송하고
메시지가 전달됐는지 확인하기 위해 Confirm.SelectOk 응답을 기다림.
이 시점에서 발행자가 RabbitMQ에 보내는 각 메시지에 대해 서버는 수신 확인(Basic.Ack) 또는 부정 수신 확인(Basic.Nack)으로 응답하며,
메시지의 오프셋을 지정하는 정수 값을 포함하거나 확인함.
확인 번호는 Confirm.Select RPC 요청 다음에 수신된 순서에 따라 메시지를 참조함.

메시지를 라우팅할 수 없는 경우, 메시지 브로커는 오류를 뜻하는 Basic.Nack RPC 요청을 반환함.
이후 발행자는 메시지를 어떻게 처리할지 결정함.

발행자 확인은 트랜잭션과 함께 사용할 수 없으며, AMQP TX 프로세스의 대안으로 가볍고 성능이 뛰어남.
또한 발행자 확인은 Basic.Publish RPC 요청에 대한 응답을 비동기로 처리하므로 확인을 받는 시점을 정확히 알 수 없음.
따라서 발행자 확인을 사용하도록 설정한 애플리케이션은 메시지를 보낸 후 언제든지 확인을 받을 수 있어야 함.
```



### 4) Using alternate-exchanges for unroutable messages

![04_04b](https://user-images.githubusercontent.com/124541871/235343625-ca5ad1ce-825f-462c-ba24-20cf574b9ad9.png)

```
대체 Exchange는 라우팅할 수 없는 메시지를 처리하기 위해 AMQP를 확장한 또 다른 예.
대체 Exchange는 처음 Exchange를 선언할 때 명시되며,
RabbitMQ에서 Exchange가 라우팅할 수 없으면, 새로운 Exchange가 기존의 Exchange를 대신해 지정됨.

대체 Exchange를 사용하려면, 먼저 라우팅할 수 없는 메시지를 전송할 Exchange를 설정해야 함.
기본 Exchange를 설정한 후, 메시지를 발행할 때 Exchange.Declare 명령에 alternate-exchange 인수를 추가함.

대체 Exchange가 설정된 Exchange로 메시지를 보낼 때 mandatory 플래그를 설정하면
의도한 Exchange가 메시지를 정상적으로 라우팅할 수 없는 경우 Basic.Return이 발행자에게 직접 전송되지 않음.
라우팅할 수 없는 메시지를 대체 Exchange에 보내는 동작은 mandatory 플래그를 True로 설정한 메시지에도 동일하게 적용됨.

RabbitMQ의 메시지 라우팅 패턴이 다른 Exchange와 마찬가지로 대체 Exchange에도 동일하게 적용된다는 점을 주의해야 함.
Queue가 원래 Routing Key로 메시지를 수신하도록 바인딩되지 않은 경우 Queue에 추가되지 않고 메시지가 손실됨.
```



### 5) Batch processing with transactions

![04_05](https://user-images.githubusercontent.com/124541871/235345904-f80fef7c-4491-4c90-ab3c-56d5659ac988.png)

```
RabbitMQ 확장 스펙인 발행자 확인을 구현하기 전에 메시지 전달을 보장하기 위한 유일한 방법은 트랙잭션이었음.
AMQP 트랜잭션 혹은 TX 클래스는 메시지를 일괄로 RabbitMQ에 발행한 후 Queue에 커밋하거나 롤백할 수 있는 매커니즘을 제공함.

트랜잭션 매커니즘은 발행자가 RabbitMQ 메시지 브로커의 Queue에 메시지를 성공적으로 전달했음을 알리는 데 사용함.
트랜잭션을 시작하기 위해 발행자는 RabbitMQ에 Tx.Select RPC 요청을 보내고 RabbitMQ 서버는 Tx.SelectOK로 응답함.
트랜잭션이 열리면 발행자는 RabbitMQ에 하나 이상의 메시지를 보낼 수 있음.

존재하지 않는 Exchange와 같은 오류로 인해 RabbitMQ가 메시지를 라우팅할 수 없으면
Tx.CommitOk 응답을 보내기 전에 Basic.Return 응답이 반환됨.
발행자가 트랜잭션을 중단하려는 경우 Tx.Rollback RPC 요청을 보내고 계속 진행하기 전에 메시지 브로커의 Tx.RollbackOK 응답을 기다려야 함.

RabbitMQ의 트랜잭션은 발행자 확인의 일괄 작업과 유사한 방식으로 동작하고 발행자에서 메시지 전달 확인 순서를 제어할 수 있음.
메시지 발행 확인을 목적으로 트랜잭션의 사용을 고려한다면 좀 더 단순한 발행자 확인을 사용하는 것이 더 빠르며 성공과 실패를 확인할 수 있음.

그러나 대부분의 경우 발행자 확인뿐만 아니라 메시지가 Queue에 있는 동안 손실되지 않는 것이 중요한데, 이는 HA Queue로 보장할 수 있음.
```

- RabbitMQ와 Atomic transaction

  ```
  원자성은 트랜잭션을 커밋하는 과정에서 트랜잭션의 모든 동작이 완료되는 것을 보장하는데,
  이는 AMQP에서 트랜잭션의 모든 작업이 완료될 때까지 클라이언트가 Tx.CommitOK 응답 프레임을 받지 않는다는 것을 뜻함.
  그러나, RabbitMQ는 발행한 모든 명령이 단일 Queue에 영향을 줄 때만 원자 트랜잭션을 지원함.
  트랜잭션의 명령이 둘 이상의 Queue에 영향을 주면 커밋은 원자적으로 동작하지 않음.
  
  트랜잭션의 모든 명령이 동일한 Queue에 영향을 줄 때만 RabbitMQ가 원자 트랜잭션을 수행하지만,
  일반적으로 발행자가 메시지를 둘 이상의 Queue에 전달하는지를 제어하지 않음.
  RabbitMQ의 고급 라우팅 기법을 사용하고 하나의 Queue에 메시지를 발행해 원자적으로 커밋하는 애플리케이션을 초기에 구축하고 나서
  추후에 동일한 Routing Key에 Queue를 쉽게 추가적으로 연결할 수 있는데,
  이 때 Routing Key를 사용하는 발행 트랜잭션은 더 이상 원자적이지 않음.
  
  delivery-mode를 2로 설정해서 디스크에 저장해야 하는 메시지가 포함된 원자 트랜잭션은 발행자의 성능에 문제를 일으킬 수 있음.
  I/O 부하가 많은 서버에서 RabbitMQ가 Tx.CommitOK 프레임을 보내기 전에 쓰기가 완료될 때까지 기다리는 경우,
  클라이언트는 트랜잭션을 사용하지 않은 경우보다 오래 기다리게 됨.
  ```



### 6) Surviving node failures with HA queues

![04_06](https://user-images.githubusercontent.com/124541871/235347063-bb3f49d5-cee8-478a-83ce-061292b3f08c.png)

```
안정적인 메시지 전달을 보장하기 위해 발행자와 RabbitMQ 간의 계약을 강화해야 하는 미션 크리티컬 메시징 아키텍처에서는
가용성이 높은 HA Queue가 중요한 역할을 함.
HA Queue도 AMQP 스펙이 아닌 RabbitMQ가 만든 확장 기능이며, Queue를 여러 서버에 중복해 복사본을 저장하는 기능을 제공.

HA Queue는 클러스터로 구성된 RabbitMQ 환경이 필요하며 AMQP API 또는 웹 기반 관리자 UI로 설정할 수 있음.

메시지가 HA Queue로 설정된 Queue에 발행되면 HA Queue를 담당하는 클러스터의 각 서버로 메시지가 전송됨.
클러스터의 노드가 메시지를 소비하면 다른 노드의 모든 메시지 복사본이 즉시 제거됨.

HA Queue는 클러스터의 모든 서버 또는 개별 노드에 적용할 수 있음.
개별 노드를 지정하려면 x-ha-policy: all 대신 nodes를 인수로 전달하고, 다음 인수인 x-ha-nodes에 Queue의 노드 목록을 지정함.

노드가 정의돼 있지 않더라도 Queue를 정의할 수 있음. 나열된 노드 중 하나 이상이 존재하는 경우 메시지는 해당 서버에 저장됨.

HA Queue에는 단일 기본 서버 노드가 지정돼 있고 다른 모든 노드는 보조 노드임.
기본 노드가 실패하면 보조 노드 중 하나가 기본 노드의 역할을 대신함.
HA Queue 구성에서 보조 노드가 다운되면 다른 노드는 계속 동작해 구성된 모든 노드에서 수행되는 작업 상태를 공유함.
다운된 노드가 다시 추가되거나 새 노드가 클러스터에 추가되더라도 기존 노드의 Queue에 이미 존재하는 메시지는 포함되지 않음.
대신 이전에 발행한 모든 메시지가 소비되면 모든 새 메시지가 수신되고 동기화됨.

HA Queue는 일반 Queue와 유사하게 동작하는데 트랜잭션 또는 발행자 확인을 사용하는 경우,
메시지가 HA Queue의 모든 활성 노드에 있는 것으로 확인될 때까지 RabbitMQ는 성공 응답을 보내지 않음.
이로 인해 발행자 애플리케이션에 대한 응답이 지연될 수 있음.
```



### 8) Persisting messages to disk via delivery-mode 2

![04_08](https://user-images.githubusercontent.com/124541871/235347874-ad9c1ee3-375e-41f9-b8b7-fb0c349bae8c.png)

```
RabbitMQ 서버가 메시지를 소비하기 전에 특정 이유로 노드가 다운될 경우,
RabbitMQ에 메시지를 발행할 때 디스크에 저장하도록 설정하지 않는다면 메시지는 영원히 소실됨.

delivery-mode는 AMQP의 Basic.Properties의 일부로 지정된 메시지 속성 중 하나.
메시지의 delivery-mode가 기본값인 1로 설정된 경우 RabbitMQ는 메시지를 디스크에 저장하지 않으며 메시지를 항상 메모리에 저장.

반면, delivery-mode가 2로 설정되면 RabbitMQ는 메시지를 디스크에 저장함.
메시지를 디스크에 저장하면 RabbitMQ 서버가 재시작된 후 메시지가 Queue에 남아있게 됨.
RabbitMQ 서버를 다시 시작한 후에도 메시지가 남아있게 하려면 Queue를 만들 때 durable로 선언되어야 함.

I/O 성능이 충분하지 않은 서버의 경우 메시지 저장 때문에 성능 문제가 발생할 수 있음.
웹 애플리케이션의 데이터베이스 서버와 마찬가지로 RabbitMQ 인스턴스는 저장된 메시지가 있는 디스크를 자주 접근해야 함.

대부분의 동적인 웹 애플리케이션의 경우 OLTP 데이터베이스의 읽기-쓰기 중에서 읽기 비율이 매우 높음.
반면, RabbitMQ에서 메시지를 디스크에 저장할 때는 쓰기 작업에 상당히 편향됨.
고성능 메시지를 처리하기 위해 RabbitMQ는 메시지를 디스크에 기록하고 더 이상 Queue에 대기하지 않을 때까지 참조로 해당 메시지를 추적함.
메시지에 대한 모든 참조가 사라지면, RabbitMQ는 디스크에서 메시지를 제거함.
고속으로 쓰기 작업을 수행한다면, 대부분의 경우 디스크 쓰기 캐시는 읽기 캐시보다 훨씬 작기 때문에
최적화해서 프로비저닝하지 않은 하드웨어에서 성능 문제가 발생하기 쉬움.
대부분의 운영체제에서 커널은 디스크에서 읽은 페이지를 버퍼링하기 위해 RAM의 여유분을 사용하지만,
디스크 쓰기를 캐시하는 유일한 컴포넌트는 디스크 컨트롤러와 디스크임.
이 때문에 메시지를 디스크에 저장할 때 하드웨어 스펙을 올바르게 설정하는 것이 중요함.
소형 서버에서는 쓰기 작업량이 과한 경우 RabbitMQ의 동작이 매우 느려질 수 있음.

I/O 부하가 많은 서버에서 운영체제는 저장 장치와 데이터를 주고받는 동안 I/O 작업을 하는 프로세스를 차단함.
RabbitMQ 서버가 디스크에 메시지 저장과 같은 I/O 작업을 수행하려고 할 때는 저장 장치가 응답하기를 기다리는 동안 운영체제 커널이 차단되고,
이를 RabbitMQ는 기다릴 수밖에 없게 됨.
RabbitMQ 서버가 운영체제가 읽기/쓰기 요청에 응답하는 데 너무 자주 대기하는 경우, 메시지 처리량이 감소할 수 있음.

메시지를 디스크에 저장하는 것은 궁극적으로 메시지의 배달을 보장하는 가장 중요한 방법 중 하나지만 가장 비용이 많이 듦.
디스크 성능이 좋지 않으면 RabbitMQ 메시지 발행 속도가 크게 저하될 수 있음.
극단적인 경우 부적절하게 프로비저닝된 하드웨어로 인한 I/O 지연 때문에 메시지가 손실될 수 있음.
다시 말해 운영체제가 I/O에서 차단돼 RabbitMQ가 발행자 또는 소비자에게 응답하지 않으면 메시지를 발행하거나 전달할 수 없음.
```

- RabbitMQ의 메시지 디스크 저장 작업을 위한 하드웨어 프로비저닝

  ```
  메시지를 디스크에 저장하는 RabbitMQ 서버의 하드웨어를 적절하게 프로비저닝하려면 OLTP 데이터베이스와 동일한 규칙을 적용하면 됨.
  
  RAM은 매우 중요.
  서버의 RAM 크기를 결정할 때, 정상적인 메시지 작업 처리뿐만 아니라 RAM의 추가 크기를 고려하면
  운영체제는 디스크 페이지를 커널 디스크 캐시에 보관함.
  이렇게 하면 디스크에서 이미 읽은 메시지에 대한 읽기 응답 시간이 향상됨.
  
  하드디스크 스핀들이 많을수록 좋음. 하드 드라이브가 많을수록 쓰기 처리량이 향상됨.
  시스템이 RAID 설정의 모든 디스크에 쓰기 작업량을 분산시킬 수 있으므로 각 물리적 장치가 차단되는 시간이 줄어듬.
  
  대량의 읽기/쓰기 캐시와 배터리 백업 기능을 갖춘 적절한 용량의 RAID 카드를 사용하는 것이 좋음.
  쓰기 작업이 RAID 카드에 의해 처리되므로 물리적 장치의 한계 때문에 차단되는 일시적인 과부하도 견딜 수 있음.
  ```

