# Foundational RabbitMQ

## 기능 / 장점

- 오픈 소스

  얼랭 작성. 오픈소스 특유의 유연함에 더해, 피보탈 사에서 운영하는 덕분에 제품으로서의 안정성까지 갖춤.

  - 얼랭 ?

    분산 처리, 장애 허용, 연성 실시간 시스템과 같이 99.999%의 가동 시간을 요구하는 애플리케이션을 위해 설계됨.

    실시간 시스템에서 경량 프로세스 간에 메시지를 전달하고 공유하는 상태가 없도록 설계돼 있으므로 높은 수준의 동시성을 제공함.

    ```
    실시간 시스템이란?
    정의한 요구 사항에 맞춰 특정한 이벤트를 전달 받았을 때 반드시 응답을 반환하는 하드웨어 플랫폼이나 소프트웨어 플랫폼.
    혹은 이 두가지의 조합을 말함.
    
    그중 연성 실시간 시스템(soft real-time system)은 작업 실행은 반드시 보장하지만 상대적으로 덜 중요한 실행의 최종 기한은 보장하지 않는 시스템을 말함.
    ```

    얼랭의 동시성 처리와 메시지 전달에 대한 설계는 RabbitMQ와 같은 메시지 브로커를 구현할 때의 장점.

    애플리케이션인 메시지 브로커는 동시에 다수 연결을 관리하고 메시지를 라우팅하며 애플리케이션 자체 상태를 관리함.

    또한 얼랭의 분산 통신 아키텍처는 RabbitMQ의 클러스터링 메커니즘을 자연스럽게 구현할 수 있음.

    다른 메시지 브로커가 클러스터링 기능을 추가하기 위해 직접 구현해야 하는 반면에

    RabbitMQ는 얼랭의 프로세스 간 통신(IPC) 시스템을 사용하므로 클러스터링 기능을 간단히 구현하였음.

- 플랫폼과 업체 중립성

  AMQP(Advanced Message Queuing Protocol) 스펙을 구현한 메시지 브로커.

  대부분의 프로그래밍 언어와 주요 플랫폼의 클라이언트도 제공됨.

  - AMQP

    메시지 프로토콜과 메시지 브로커는 다양하므로, 애플리케이션을 개발할 때는 애플리케이션에 미치는 영향을 고려해 메시지 프로토콜과 메시지 브로커를 선택해야 함.

    RabbitMQ는 AMQP를 기반으로 구현됐지만 MQTT, STOMP, XMPP 등 다양한 프로토콜도 제공함.

    다른 메시지 브로커와 비교할 때 RabbitMQ는 다양한 프로토콜과 플러그인을 제공하므로 멀티 프로토콜 애플리케이션 아키텍처에는 좋은 선택임.

    RabbitMQ는 AMQP 스펙을 구현했는데, 주요 아키텍처와 통신 방식이 핵심임. 이는 다른 메시지 브로커와 비교하며 평가할 때 중요한 차이점.

    AMQP를 구현한 RabbitMQ는 유연한 메시지 라우팅, 메시지 내구성 설정, 데이터센터 간 통신 등 메시지 지향 아키텍처의 복잡한 요구 사항에 대한 벤더 중립적이며 플랫폼 독립적인 솔루션.

- 경량성

  관리자 UI 플러그인과 함께 코어 애플리케이션을 구동하는 데 40MB 미만의 메모리만 사용함.

  이후, Queue에 전송되는 메시지양이 증가함에 따라 메모리 사용량이 점차 증가.

- 다양한 클라이언트 라이브러리

  대부분의 프로그래밍 언어와 플랫폼에 클라이언트 라이브러리가 제공되고 있으며,

  이는 RabbitMQ를 메시지 브로커로 성택하는 데 큰 장점.

- 유연한 성능과 안정성 절충 제어

  안정적인 메시지 전달과 메시지 처리량 혹은 성능을 유연하게 제어할 수 있는 옵션을 제공함.

  메시지를 배달하기 전에 디스크에 저장하도록 설정할 수 있으며,

  클러스터를 설정할 때 Queue를 HA로 설정해서 여러 노드에 걸쳐 저장하므로 일부 서버 장애로 메시지가 손실되지 않도록 처리할 수 있음.

- 대기 시간이 긴 네트워크 환경을 위한 플러그인

  실제 시스템의 네트워크 토폴로지와 아키텍처는 다양하게 구성되기 때문에

  대기 시간이 짧은 네트워크 환경에서의 메시지 전달은 기본 코어 모듈로 제공하고

  인터넷과 같이 대기 시간이 긴 네트워크 간의 메시지 전달은 플러그인을 통해 제공함.

  RabbitMQ를 이용해 동일한 로컬 네트워크에 클러스터를 구성할 수 있고 Federation 플러그인으로 여러 데이터센터 간 메시지를 공유할 수 있음.

- 서드파티 플러그인

  시스템에서 애플리케이션 간 중심 역할을 하는 RabbitMQ는 유연한 플러그인 시스템을 제공함.

  예를 들어 RabbitMQ를 사용해 메시지를 데이터베이스에 직접 저장하는 서드파티 플러그인도 사용할 수 있음.

- 보안 계층

  보안을 여러 단계로 제공함.

  클라이언트의 접속은 인증서의 유효성을 검증하는 SSL만으로 제한함으로써 안전하게 처리하고 있으며,

  가상 호스트로 사용자 접근을 관리해 메시지와 리소스를 고수준으로 격리해서 처리하고 있음.

  또한 구성 기능에 대한 접근, Queue에서 읽기 및 익스체인지에 대한 쓰기는 정규식 패턴 매칭으로 관리함.

  마지막으로 LDAP(Lightweight Directory Access Protocol, 사용자가 조직, 구성원 등에 대한 데이터를 찾는 데 도움이 되는 프로토콜)과 같은 외부 인증 시스템에 통합하기 위해 플러그인을 사용할 수 있음.



## 느슨하게 결합된 아키텍처의 장점

### 애플리케이션 의존성 제거

```
메시지 기반 미들웨어를 사용해서 데이터 중심의 유연한 아키텍처로 구조를 변경하면 다양한 장점을 확인할 수 있음.
RabbitMQ를 사용해 느슨하게 결합된 설계로 변경함으로써 애플리케이션 아키텍처는 더 이상 데이터베이스 쓰기 성능에 영향을 받지 않으며,
핵심 애플리케이션의 코드를 수정하지 않고도 데이터를 처리하는 새로운 애플리케이션을 쉽게 추가할 수 있음.
```

- 메시지 기반 미들웨어 ?

  ```
  MOM, Message-oriented-middleware)는 분산 시스템에서 메시지를 보내고 받을 수 있는 소프트웨어 또는 하드웨어 인프라를 말함.
  RabbitMQ는 향상된 메시지 라우팅 및 분배 기능을 제공하고 안정적인 분산 시스템을 지원하기 위해
  광역 네트워크(WAN)를 통해 다른 시스템과 손쉽게 연결할 수 있는 메시지 지향 미들웨어 중 하나.
  ```

### 데이터베이스 쓰기 의존성 제거

```
데이터베이스와 강결합된 애플리케이션은 데이터베이스 서버가 트랜잭션을 완료하고 응답할 때까지 기다려야 함.
데이터베이스와 강결합된 구조는 동기 애플리케이션과 비동기 애플리케이션 모두에서 성능상의 병목이 발생할 가능성이 있음.
잘못된 튜닝이나 하드웨어 문제로 인해 데이터베이스 서버가 느려지면 애플리케이션도 느려지고
데이터베이스가 응답을 멈추거나 장애가 발생하면 애플리케이션에도 장애가 발생함.
애플리케이션과 데이터베이스의 의존성을 분리해서 강결합 구조를 약결합 구조로 변경할 때,
메시지 지향 미들웨어인 RabbitMQ는 데이터베이스에서 작업을 수행하기 전 데이터의 중개자 역할을 함.
소비자 애플리케이션은 RabbitMQ 서버에서 데이터를 가져와서 데이터베이스 작업을 수행함.

이 모델에서는 유지 보수를 위해 데이터베이스를 오프라인으로 전환해야 하거나
쓰기 작업량이 너무 많아지면 소비자 애플리케이션의 처리량을 제어하거나 중지할 수 있음.
소비자 애플리케이션이 메시지를 수신할 수 있을 때까지 데이터는 큐에 저장됨.
소비자 애플리케이션의 동작을 일시 중지하거나 처리량을 제어할 수 있는 점은 약결합 구조의 여러 장점 중 하나.
```

![rabbitmq structure](https://user-images.githubusercontent.com/124541871/233778967-ceb53614-7f76-4e51-b4b5-32920b2b9720.png)



## AMQ 모델

```
RabbitMQ의 강점과 유연성 등은 대부분 AMQP 스펙에서 비롯됨.
HTTP, SMTP와 같은 프로토콜과 달리 AMQP 스펙은 네트워크 프로토콜의 정의뿐 아니라 서버 측 서비스와 동작 방식도 정의하는데,
AMQ(Advanced Message Queuing) 모델을 살펴보면 확인할 수 있음.
AMQ 모델은 메시지 라우팅 동작을 정의하는 메시지 브로커의 세 가지 추상 컴포넌트 정의함.
	- Exchange: 메시지 브로커에서 Queue에 메시지를 전달하는 컴포넌트
	- Queue: 메시지를 저장하는 디스크상이나 메모리상의 자료 구조
	- Binding: Exchange에 전달된 메시지가 어떤 Queue에 저장돼야 하는지 정의하는 컴포넌트

RabbitMQ는 Exchange에서 Queue로 메시지를 라우팅하는 방법이 동적임.
Exchange와 Queue 간의 이러한 연결과 메시지 라우팅 동적 특성은 메시지 지향 아키텍처를 구현하는 기본 요소임.
RabbitMQ에서 세 가지 기본 컴포넌트를 사용해 올바른 구조를 구성하면 애플리케이션을 확장하고 기본 비즈니스 요구에 맞춰 쉽게 기능을 변경할 수 있음.
```



### Exchange

```
RabbitMQ에서 메시지를 적절한 목적지로 전달하기 위해 필요한 첫 번째 입력 값으로 AMQ 모델이 정의하는 세 컴포넌트 중 하나.
Exchange는 RabbitMQ로 전송한 메시지를 수신하고 메시지를 보낼 위치를 결정하고 메시지에 적용할 라우팅 동작을 정의하는데,
이는 일반적으로 메시지를 보낼 때 함께 전달한 데이터 속성을 검사하거나 메시지에 포함된 속성을 이용해 처리함.
RabbitMQ에는 서로 다른 라우팅 동작을 처리하는 여러 유형의 Exchange가 있음. 플러그인을 사용해서 Custom Exchange도 정의할 수 있음.
```

- Exchange를 이용해 메시지를 전달함으로써 발행 애플리케이션에 메시지를 보내는 구조

  ![hello-world-example-routing](https://user-images.githubusercontent.com/124541871/233780031-1b330548-6993-4ec0-95bb-ef760f6c6d72.png)



### Queue

```
Queue는 수신한 메시지를 저장하는 역할을 하며 메시지에 수행하는 작업을 정의하는 설정 정보가 있음.
Queue의 설정 정보에는 메시지를 메모리에만 보관하거나 소비자에게 전달하기 전에 FIFO 순서로 메시지를 디스크에 보관하는지가 저장되어 있음.
```



### Binding

```
AMQ 모델은 Binding을 사용해서 Queue와 Exchange의 관계를 정의함.
RabbitMQ에서 Binding Key는 Exchange가 어떤 Queue에 메시지를 전달해야 하는지를 의미함.

Exchange 중 특정 유형은 Exchange에 지정한 특정 Queue에만 메시지를 전달하도록 메시지를 필터링함.
Exchange에 메시지를 발행할 때 애플리케이션은 Routing Key 속성을 사용함.
Routing Key는 때로는 Queue의 이름이거나 의미적으로 메시지를 설명하는 문자열임.

Exchange는 적절하게 메시지를 Queue로 전달하기 위해 메시지의 Routing Key를 Binding Key에 맞춰서 평가함.
즉, Binding Key는 Queue를 Exchange에 연결하고 Routing Key를 평가하는 기준임.

각 Exchange의 유형마다 다르지만, 단순하게 사용한다면 Routing Key는 Queue의 이름임.
RabbitMQ에서 각 Exchange 유형은 서로 다른 방식으로 Routing Key를 처리하는데,
특정 Exchange는 단순히 Routing Key의 이름이 동일한지 검사하고
또 다른 유형의 Exchange는 Routing Key에서 좀 더 복잡한 패턴을 추출해 검사함.
메시지 속성에 정의한 다른 속성을 우선적으로 평가해 Routing Key를 완전히 무시하는 Exchange 유형도 있음.

AMQ 모델에 정의한 Queue를 Exchange에 연결하는 방식 외에도 RabbitMQ에서는 AMQP 스펙을 확장해 특정 Exchange를 다른 Exchange에 연결할 수 있는데,
이는 메시지를 라우팅하는 데 상당한 유연성을 제공함.
```

![Exchanges-and-bindings](https://user-images.githubusercontent.com/124541871/233780368-d134baa9-2da5-47ec-a213-f0aaaf09caed.png)

