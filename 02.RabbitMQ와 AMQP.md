# RabbitMQ와 AMQP

## 1. RPC 전송으로서의 AMQP

```
RabbitMQ는 AMQP 메시지 브로커로 코어 서버와 통신하는 거의 모든 부분에서 RPC 패턴으로 엄격하게 통신함.
RPC는 한 컴퓨터에서 다른 컴퓨터의 프로그램이나 프로그램의 메소드를 원격에서 실행할 수 있게 해주는 컴퓨터 간의 통신 유형 중 하나.
원격 API와 통신하는 웹 프로그램이 있다면, 이는 일반적인 RPC 패턴을 사용했다고 볼 수 있음.

그러나 RabbitMQ와 통신할 때 발생하는 RPC는 일반적인 웹 기반 API와는 다른 부분이 많음.
대부분의 웹 API는 클라이언트가 명령을 실행하고 서버가 응답하는 방식으로 정의돼 있으며,
서버가 명령을 클라이언트로 다시 보내지 않음.
반면 AMQP 스펙은 서버와 클라이언트 모두 명령을 실행할 수 있음.
이는 클라이언트 애플리케이션도 애플리케이션의 동작과 거의 관련 없는 통신을 서버로부터 청취해야 함을 의미.
```


- RPC(Remote Procedure Call) ?

    ```
    IPC 방법의 한 종류.
    별도의 원격 제어를 위한 코딩 없이 다른 주소 공간에서 함수나 프로시저를 실행할 수 있게하는 프로세스 간 통신 기술.
    다시 말해, 원격 프로시저 호출을 이용하면 프로그래머는 함수 혹은 프로시저가
    실행 프로그램이 존재하는 로컬 위치에 있든 원격 위치에 있든 동일한 코드를 이용할 수 있음.
    
    객체 지향의 원칙을 사용하는 소프트웨어의 경우 원격 프로시저 호출을 원격 호출 또는 원격 메소드 호출이라고 말함.
    
    일반적으로 프로세스는 자신의 주소공간 안에 존재한느 함수만 호출하여 실행 가능함.
    그러나, RPC의 경우 자신과 다른 주소공간에서 동작하는 프로세스의 함수를 실행할 수 있게 해주는데,
    이는 네트워크를 통한 메시징을 수행하기 때문.
    
    RPC 모델은 분산컴퓨팅 환경에서 많이 사용되어 왔으며, 현재는 MSA에서 마이크로 서비스 간에도 많이 사용함.
    ```



### 1) 대화 시작하기

```
외국에서 어떤 사람과 대화를 나눠야 한다고 가정하면 둘 중 한 명은 인사말로 대화를 시작할 텐데,
이는 두 사람 모두 알고 있는 언어를 서로 확인하는 과정이 됨.

AMQP로 통신을 시작할 때, 이 인사말은 Protocol Header에 해당되는데 클라이언트가 서버로 전송함.
이 인사말은 요청으로 간주돼서는 안 되며 다른 통신과는 달리 명령도 아님.
클라이언트의 요청을 받은 RabbitMQ는 Connection.Start 명령으로 인사말에 응답해 명령/응답 흐름을 시작하고
클라이언트는 Connection.StartOk 응답 프레임으로 RPC 요청에 응답함.

클라이언트 라이브러리를 직접 작성하지 않는다면 RabbitMQ와의 연결 시작에 대한 상세 내용을 알기 어렵지만,
RabbitMQ에 접속을 완료하기 위한 일련의 세 가지 동기식 RPC 요청인 start, tune, open은 주목할 만한 가치가 있음.
이 과정이 끝나면, RabbitMQ는 애플리케이션의 요청을 받을 준비를 마치게 됨.
```

![02_01](https://user-images.githubusercontent.com/87686562/233789934-4e01cc57-f842-4172-ba83-bae09f8c7060.png)



### 2) 올바른 채널로 튜닝

```
양방향 라디오 채널과 유사하게 AMQP 스펙에는 RabbitMQ와 통신하기 위한 채널이 정의돼 있었음.
양방향 라디오는 전파를 사용해 서로 정보를 전송함.
AMQP에서 채널은 연결 협상(handshake)이 완료된 AMQP 연결을 정보 전송을 위한 수도관처럼 사용하고
라디오 채널과 마찬가지로 발생 중인 다른 채널의 대화로부터 전송을 격리함.
단일 AMQP 연결에는 여러 채널이 있으므로 클라이언트와 서버 간에 여러 대화를 수행할 수 있음.
이는 Multiplexing이라 부르며 여러 작업을 수행하는 멀티스레드 또는 비동기 애플리케이션에 유용함.
```

- Tip

  ```
  RabbitMQ를 이용해서 클라이언트 애플리케이션을 구현할 때는 복잡하게 너무 많은 채널을 사용하지 않는 것이 좋음.
  AMQP의 Marshalling된 프레임에서 채널은 서버와 클라이언트 간에 전달되는 메시지에 할당된 정수 값에 불과하지만,
  RabbitMQ 서버와 클라이언트에서 채널은 더 많은 리소스를 사용함.
  각 채널마다 메모리 구조와 객체가 설정되어 있음.
  연결에 채널이 많을수록 RabbitMQ는 그 연결에 대한 메시지 흐름을 관리하는 데 더 많은 메모리를 사용해야 함.
  채널을 적당하게 사용해 원활한 RabbitMQ 서버와 복잡하지 않은 애플리케이션을 유지하는 것이 좋음.
  ```



## 2. AMQP의 RPC 프레임 구조

```
AMQP 스펙에는 프로그래밍 언어의 객체 지향 개념과 유사한 클래스와 메소드를 사용하며
클라이언트와 서버 간의 공통 모델인 AMQP 명령이 정의되어 있음.
AMQP의 클래스는 기능의 범위를 정의하며 각 클래스에는 서로 다른 작업을 수행하는 메소드가 있음.
연결 협상 과정에서 RabbitMQ 서버는 프레임으로 Marshalling된 Connection.Start 명령을 클라이언트로 전송함.
Connection.Start 명령에는 AMQP 클래스와 메소드라는 두 가지 구성요소가 있음.
```



### 1) AMQP 프레임 컴포넌트

```
RabbitMQ에서 AMQP 명령을 전송하거나 수신할 때 필요한 모든 인자들은 데이터 구조로 캡슐화된 프레임으로 인코딩돼 전송됨.
프레임은 명령과 해당 인자를 인코딩해 각 프레임이 서로 구분되도록 하는 효율적인 방법임.
프레임은 지하철의 열차 한 칸과 같이 서로 동일한 기본 구조로 구성돼 있으며 포함하고 있는 내용으로 서로 구분됨.
저수준 AMQP 프레임도 마찬가지임. 저수준 AMQP 프레임은 다섯 개의 별개 구성 요소로 구성됨.
	1. Frame Type
	2. Channel Number
	3. Frame Size(Byte)
	4. Frame Payload
	5. End Byte Marker(ASCII 값, 1 Byte)

저수준 AMQP 프레임은 세 개의 필드로 구성된 프레임 헤더로 시작함.
첫 번째 필드는 프레임 유형을 나타내는 단일 바이트, 두 번째 필드는 프레임이 속하는 채널을 지정.
세 번째 필드는 프레임 본문의 크기를 바이트로 표현.
프레임 구조체의 마지막에는 프레임의 끝을 나타내는 바이트 마커가 있음.
프레임 내부 헤더와 마지막 바이트 마커 사이에는 페이로드가 있음.
```

<img width="668" alt="amqp_frame" src="https://user-images.githubusercontent.com/87686562/233788273-ee32288d-ace6-4450-ad83-e1ce9e951210.png">



### 2) 프레임 유형

```
AMQP 스펙에는 프로토콜 헤더 프레임, 메소드 프레임, 콘텐츠 헤더 프레임, 바디 프레임, 하트비트 프레임 등 다섯 가지 유형의 프레임이 정의돼 있음.
각 프레임 유형은 각각 고유한 목적을 가지고 있으며 일부는 다른 프레임에 비해 훨씬 자주 사용됨.
	- 프로토콜 헤더 프레임은 RabbitMQ에 연결할 때 한 번만 사용됨.
	- 메소드 프레임은 RabbitMQ와 서로 주고받는 RPC 요청이나 응답을 전달함.
	- 콘텐츠 헤더 프레임은 메시지의 크기와 속성을 포함함.
	- 바디 프레임은 메시지의 내용을 포함함.
	- 하트비트 프레임은 RabbitMQ와 연결된 클라이언트와 서버가 주고받으며 서로 사용 가능한 상태인지 확인하는 데 사용.

프로토콜 헤더 프레임과 하트비트 프레임은 일반적으로 클라이언트 라이브러리를 사용할 때 추상화돼 라이브러리의 사용자에게는 직접 보이지 않지만,
메소드 프레임, 콘텐츠 헤더 프레임, 바디 프레임은 RabbitMQ와 통신하는 애플리케이션을 작성할 때 해당 구조가 표면적으로 보임.
```

- Note

  ```
  AMQP의 하트비트 동작은 클라리언트와 서버가 서로의 요청에 응답하는지 확인하는 데 사용하며 AMQP가 양방향 RPC 프로토콜임을 알 수 있는 완벽한 예.
  RabbitMQ가 클라이언트 애플리케이션에 하트비트를 보냈는데 응답하지 않으면 RabbitMQ는 클라이언트와의 연결을 끊음.
  보통 단일 스레드 또는 비동기 개발 환경에서는 제한 시간을 약간 큰 값으로 늘림.
  하트비트가 동작하기 어려운 환경에서 애플리케이션을 구동해 통신이 차단되는 경우,
  클라이언트 연결을 만들 때 하트비트 간격을 0으로 설정해 하트비트를 끌 수 있음.
  대신 기본값인 600초보다 더 큰 값으로 rabbitmq.config 파일의 하트비트 값을 변경해 RabbitMQ의 최대 하트비트 간격 값을 변경할 수 있음.
  ```



### 3) 메시지를 프레임으로 Marshalling

```
RabbitMQ에 메시지를 발행할 때 메소드 프레임, 헤더 프레임, 바디 프레임이 사용됨.
첫 번째 전송되는 프레임은 명령을 전달하는 메소드 프레임이며, 실행하는 데 필요한 매개변수인 Exchange와 Routing Key를 함께 전송함.
메소드 프레임 다음에는 콘텐츠에 해당되는 프레임들이 이어지는데, 이는 콘텐츠 헤더 프레임과 바디 프레임임.
콘텐츠 헤더 프레임에는 본문 크기와 함게 메시지 속성이 포함돼 있음.
AMQP에는 최대 프레임 크기가 있으며 메시지 본문이 이 크기를 초과하면 콘텐츠가 여러 바디 프레임으로 분할됨.
항상 동일한 순서인 메소드 프레임, 콘텐츠 헤더 프레임 그리고 하나 이상의 바디 프레임 순으로 전송됨.

RabbitMQ에 메시지를 보낼 때 메소드 프레임에 Basic.Publish 명령이 전송된 다음
메시지의 내용 유형 및 메시지가 전송된 시간과 같은 메시지 속성이 포함된 콘텐츠 헤더 프레임이 이어짐.
이 속성은 AMQP 스펙에 정의된 Basic.Properties 데이터 구조로 캡슐화 됨.
마지막으로 메시지의 내용이 적절한 수의 바디 프레임으로 Marshalling 됨.

프레임의 기본 크기는 131KB지만,
클라이언트 라이브러리는 연결 과정 중 최대 32bit로 표현할 수 있는 범위 내에서 최대 프레임 크기를 서버와 협상함.

전송하는 데이터의 크기를 최소화하기 위해 메소드 프레임과 콘텐츠 헤더 프레임의 내용은 이진 데이터로 구성되어 있으므로 사람은 읽을 수 없음.
메소드 프레임 및 콘텐츠 헤더 프레임과 달리 바디 프레임의 내부의 전달되는 메시지 내용은 어떤 방식으로도 압축되거나 인코딩돼 있지 않으며
일반 텍스트에서 이진 이미지 데이터에 이르기까지 다양한 형태가 저장될 수 있음.
```

![amqp frames](https://user-images.githubusercontent.com/87686562/233789587-6a90cc09-50cd-4d30-a1d6-6cf2d8e00764.png)



### 4) Method Frame

![method frame](https://user-images.githubusercontent.com/87686562/233789662-494fd6a4-c631-4b9a-b674-a483e16ccb09.png)

```
RPC 요청이 처리할 클래스와 메소드 그리고 실행을 위한 인수를 함께 전달함.
Basic.Publish 명령을 전달하는 메소드 프레임에는 명령을 설명하는 바이너리 데이터와 함게 전달되는 요청 인자가 들어 있음.
처음 두 필드는 숫자로 표현된 Basic 클래스와 Publish 메소드임.
이어서 Exchange의 이름과 Routing Key가 문자열로 저장됨. 이 두 속성은 RabbitMQ 서버에게 메시지의 경로 지정 방법을 전달함.
마지막 mandatory 플래그는 RabbitMQ에게 메시지가 정상적으로 전달됐는지 혹은 실패했는지를 알려줌.

메소드 프레임 페이로드의 각 데이터 값은 유형별로 서로 다른 포맷으로 인코딩되는데
유선 상에서 바이트 크기를 최소화하고 데이터 무결성을 보장하며 데이터 마샬링, 언마샬링을 가능한 한 빨리 처리하도록 설계돼 있음.
실제 포맷은 데이터 유형에 따라 다르지만, 대개 단일 바이트 다음에 숫자 데이터 또는 바이트 크기 필드와 텍스트 데이터가 이어짐.

일반적으로 Basic.Publish RPC 요청을 사용해 메시지를 보내는 작업은 단방향 통신임.
사실 일반적으로 AMQP 스펙은 요청이 성공한 경우 조용하게 처리하지만, 오류가 발생하면 가능한 한 개발자가 알아채기 쉽게 소란스레 처리함.
그러나 메시지를 발행할 때 mandatory 플래그를 사용하는 경우 애플리케이션은 RabbitMQ에서 응답한 Basic.Return 명령을 수신해야 함.
RabbitMQ가 mandatory 플래그에 설정한 요구 사항을 충족시키지 못하면 Basic.Return 명령을 동일한 채널의 클라이언트에 전송함.
```



### 5) Content Header Frame

![02_06](https://user-images.githubusercontent.com/87686562/233790007-ae12a698-62de-4d40-8fe5-d6cad97a6f16.png)

```
RabbitMQ에 메시지의 크기와 그 외 데이터를 전달함.
RabbitMQ 서버와 애플리케이션 사이에 주고받는 메시지를 설명하는 속성을 포함함.
이러한 속성은 Basic.Properties 테이블의 값으로 메시지의 내용을 설명하는 데이터가 포함돼 있거나 비어있을 수 있음.
대부분의 클라이언트 라이브러리는 content-type이나 delivery mode와 같은 최소한의 필드는 미리 채움.

메시지 속성은 메시지를 작성할 때 강력한 도구로 사용됨.
발행자와 구독자 간에 메시지 내용에 대한 약속을 만드는 데 사용될 수 있고, 특별히 많은 양을 저장할 수 있도록 설계되어 있음.
```



### 6) Body Frame

![02_07](https://user-images.githubusercontent.com/87686562/233790314-4a28c3a7-9dde-4663-b5ae-6bba05a8479e.png)

```
전송되는 데이터 유형에 대해 독립적이며 이진 데이터 혹은 텍스트 데이터를 포함함.
메시지는 JPEG 이미지나 JSON 또는 XML 형식으로 직렬화한 데이터를 전송할 수 있음.

메시지의 데이터는 메시지 속성과 본문으로 구분돼 저장됨.
RabbitMQ에서 메시지 속성과 본문이 서로 의존적이지 않으므로 둘을 결합해서 다양한 유형의 데이터를 표현할 수 있게 됨.
```



## 3. Putting the protocol to use

```
메시지를 큐에 발행하기 전에 몇 가지 설정 단계를 거쳐야 하는데, 최소한 Exchange와 Queue를 설정한 후 둘을 연결해야 함.
```



### 1) Declaring Exchange

![02_08](https://user-images.githubusercontent.com/87686562/233790716-4fe2e681-ecce-476e-b351-b3203e513b8b.png)

```
AMQ 모델에서 Exchange는 Queue와 같이 '1급 시민'으로 AMQP 스펙에 해당 클래스가 존재함.
Exchange.Declare 명령에 Exchange의 이름과 유형 그리고 메시지 처리에 사용하는 기타 메타데이터를 인수로 실행해서 Exchange 생성.

Exchange.Declare 명령을 전송하면 RabbitMQ는 Exchange를 생성한 후 Exchange.DeclareOk 메소드 프레임을 응답으로 전송함.
만일 특정 이유로 Exchange.Declare 명령이 실패하면
RabbitMQ는 선언 실패와 채널이 닫힌 이유를 나타내는 응답 코드를 Channel.Close에 포함시켜 전송하고 명령이 전송된 채널을 닫음.
```



### 2) Declaring Queue

![02_09](https://user-images.githubusercontent.com/87686562/233790911-6779cc29-1ab8-4fbb-b74b-446f94744c30.png)

```
Exchange를 생성한 후 RabbitMQ에 Queue.Declare 명령을 보내 Queue를 생성함.
Queue.Declare 명령도 Exchange.Declare 명령과 유사한 통신 절차로 진행되며 Queue.Declare 명령이 실패하면 채널이 닫힘.

Queue를 선언할 때 동일한 Queue.Declare 명령을 두 번 이상 전송해도 문제는 발생하지 않음.
RabbitMQ는 중복된 Queue 선언을 감지해 Queue에 대기 중인 메시지의 수와 구독 중인 구독자의 수와 같이 Queue에 대한 유용한 상태를 반환함.
```

- HANDLING ERRORS GRACEFULLY

  ```
  이미 생성한 Queue와 같은 이름이지만, 속성이 다른 Queue를 선언하려고 시도하면 RabbitMQ는 RPC 요청을 발행한 채널을 닫음.
  이는 클라이언트 애플리케이션이 메시지 브로커에 명령을 내릴 때 발생하는 다른 유형의 에러와 동작이 같음.
  예를 들어 가상 호스트의 설정에 대해 접근 권한이 없는 사용자가 Queue.Declare 명령을 실해앟면 403 에러가 반환되고 채널은 닫힘.
  
  클라이언트 애플리케이션이 에러를 정상적으로 처리하려면 RabbitMQ로부터 Channel.Close 명령을 전달받아 적절하게 응답해야 함.
  특정 클라이언트 라이브러리는 에러 응답을 애플리케이션이 처리할 수 있는 예외로 변환해 처리하며,
  다른 유형의 라이브러리는 사용자가 메소드를 등록할 때 Callback을 추가하도록 하고
  Channel.Close 명령을 보낼 때 Callback을 호출하는 식으로 처리하기도 함.
  
  클라이언트 애플리케이션이 서버에서 전송하는 이벤트를 수신하지 않거나 적절하게 처리하고 있지 않으면 메시지가 손실될 수 있음.
  존재하지 않거나 이미 닫힌 채널에 메시지를 발행하는 경우 RabbitMQ는 연결을 종료함.
  메시지를 소비하는 애플리케이션이 RabbitMQ가 채널을 닫은 사실을 모르는 경우 RabbitMQ가 메시지를 더는 전송하지 않지만,
  클라이언트는 빈 Queue를 구독하고 있다고 간주하는 문제가 발생함.
  ```



### 3) Binding Queue to Exchange

![02_10](https://user-images.githubusercontent.com/87686562/233791297-e614527e-b30a-4ab6-a79d-965c2eefaca6.png)

```
Queue.Declare와 유사하게 Queue를 Exchange에 연결하는 명령인 Queue.Bind는 한 번에 하나의 Queue만 지정함.
Queue.Bind 명령은 실행이 성공적으로 처리된 경우 클라이언트 애플리케이션에 Queue.BindOk 메소드 프레임을 전송함.

Exchange.Declare, Queue.Declare, Queue.Bind 명령은 RabbitMQ 서버와 클라이언트 간 RPC의 기본 명령으로
AMQP spec에서 다른 동기 방식의 명령도 이 공통 패턴을 따르고 있음.
하지만 몇 가지 비동기 명령들은 RabbitMQ에 메시지를 보내고 받는 식의 패턴으로 실행됨.
```



### 4) Publising Message to RabbitMQ

![02_11](https://user-images.githubusercontent.com/87686562/233791965-c080cd61-e377-47b0-a888-e5e10951c8b4.png)

```
RabbitMQ에 메시지를 발행할 때 여러 종류의 프레임들이 서버로 전송하는 메시지의 데이터를 캡슐화함.
실제 메시지 본문을 RabbitMQ에 전달하기 전에 클라이언트 애플리케이션은 Basic.Publish 메소드 프레임, 콘텐츠 헤더 프레임, 하나 이상의 바디 프레임을 전송함.

메시지의 모든 프레임을 수신한 후에 RabbitMQ는 메소드 프레임에 포함된 필요한 정보를 검증함.
Basic.Publish 메소드 프레임에는 Exchange의 이름과 Routing Key가 들어있는데,
이를 RabbitMQ는 Exchange의 이름을 저장한 데이터베이스와 비교함.

RabbitMQ에 존재하지 않는 Exchange에 메시지를 발행하는 경우, 기본적으로 메시지는 자동으로 버려짐.
메시지가 제대로 발행됐는지 확인하려면, 메시지 발행 시에 mendatory 플래그를 true로 설정하거나 발행자 확인(publisher confirmations)을 사용해야 함.
이 중 하나를 사용하면 애플리케이션의 메시지 발행 속도가 저하될 수 있으니 주의해야 함.

RabbitMQ가 Basic.Properties 메소드 프레임의 Exchange 이름과 일치하는 Exchange를 발견한 후,
해당 Exchange는 내부 Binding들을 평가하며 Routing Key와 일치하는 Queue를 찾음.
메시지의 평가 내용이 Exchange에 연결된 Queue와 일치하면 RabbitMQ 서버는 FIFO 순서로 메시지를 Queue에 삽입함.
실제 메시지를 Queue에 넣는 대신 메시지에 대한 참조가 Queue에 추가됨.
RabbitMQ가 메시지를 전달할 준비가 되면 Queue는 이 참조를 사용해 메시지를 Marshalling함으로써 클라이언트에 전송함.
여러 Queue에 발행한 메시지는 실질적으로는 이 참조를 이용해 최적화됨.
하나의 메시지가 여러 목적지에 발행될 때, 인스턴스의 참조만 저장하므로 실제 메모리를 적게 사용하게 됨.
특정 Queue에 대기 중인 메시지가 소비되거나 만료 또는 유휴로 인해 제거될 때, 다른 Queue의 메시지 처리에 영향을 주지 않음.
메시지의 모든 사본이 배달되거나 제거돼서 RabbitMQ가 더 이상 메시지를 필요로 하지 않으면,
메시지 데이터의 단일 복사본은 RabbitMQ의 메모리에서 제거됨.

Queue를 구독하는 소비자가 없어서 메시지를 소비하지 않는다면 메시지는 Queue에 계속 저장되고 메시지를 더 추가할수록 Queue의 크기도 커짐.
RabbitMQ는 메시지의 Basic.Properties에 지정된 Delivery mode에 따라 메시지를 메모리에 보관하거나 디스크에 기록함.
```



### 5) Consuming messages from RabbitMQ

![02_12](https://user-images.githubusercontent.com/87686562/233792438-6dfc064a-500d-4716-a796-d292726a7d51.png)

```
RabbitMQ의 Queue에서 메시지를 소비하기 위해 소비자 애플리케이션은 Basic.Consume 명령을 실행해서 RabbitMQ의 Queue를 구독함.
서버는 Basic.ConsumOk로 응답해 클라이언트가 연속해서 메시지를 받을 준비를 하도록 알림.
RabbitMQ의 판단에 따라, 소비자는 응답받기 적당한 형태인 Basic.Deliver 메소드 프레임과 콘텐츠 헤더 프레임, 바디 프레임으로 메시지를 전달받음.

Basic.Consume이 발급되면 특정 상황이 발생하기 전까지 활성 상태를 유지함.
소비자가 메시지 수신을 중지하려면 Basic.Cancel 명령을 발행해야 함.

RabbitMQ가 계속해서 메시지를 보내는 동안에 명령이 비동기적으로 실행됨.
소비자는 Basic.CancelOk 응답 프레임을 받기 전에 RabbitMQ가 미리 할당한 메시지 수만큼 메시지를 받을 수 있음.

메시지를 소비할 때 RabbitMQ에는 소비자의 수신 방식을 알 수 있는 몇 가지 설정이 있는데,
그중 하나는 Basic.Consume 명령의 no_ack 인수임.
no_ack를 true로 설정하면 RabbitMQ는 소비자가 Basic.Cancel 명령을 보내거나 연결을 끊을 때까지 계속 메시지를 보냄.
no_ack 플래그를 false로 설정하면 소비자는 Basic.Ack RPC 요청을 전송해 수신한 각 메시지를 확인해야 함.

Basic.Ack 응답 프레임이 전송되면 소비자는 Basic.Deliver 메소드 프레임에 Delivery Tag 인수를 전달해야 함.
RabbitMQ는 채널과 함께 Delivery Tag를 고유한 식별자로 사용해서 메시지 수신을 확인하거나 거절 또는 부정적인 수신을 확인함.
```

- Basic.Cancel 명령을 전송하기 전까지 RabbitMQ가 전달한 각 메시지를 클라이언트가 성공적으로 받으면 Basic.Ack로 응답하는데, no_ack를 지정하면 Basic.Ack 단계가 생략됨.

  ![02_13](https://user-images.githubusercontent.com/87686562/233792780-ba0e2bb4-de15-46a9-9c70-b43e3d50aa82.png)
